/**
 * \file payment_utils.c
 *
 * General purpose module that houses basic useful functionality for various
 * users of the moneTor payment scheme. This module will be likely updated
 * frequently as the scheme is expanded
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "payment_utils.h"

/**
 * Accepts a signed_msg struct and packs it into a network-sendable byte
 * string. The provided str_out pointer will be written with a malloc'd byte
 * string. The user is responsible for freeing this string after use. The size
 * of the outputted string is returned
 */
int pack_signed_msg(signed_msg msg_struct, byte** str_out){
    *str_out = malloc(sizeof(signed_msg) + msg_struct.size);
    memcpy((*str_out) + sizeof(signed_msg), msg_struct.msg, msg_struct.size);
    msg_struct.msg = NULL;  // avoid complications by copying old location
    memcpy(*str_out, &msg_struct, sizeof(signed_msg));

    return sizeof(msg_struct) + msg_struct.size;
}

/**
 * Accepts a byte string and converts it into a signed_msg struct. Returns an
 * integer indicating success for the sake of convention, but the function
 * technically cannot tell if it outputs garbage.
 */
int unpack_signed_msg(byte* str, signed_msg* struct_out){

    memcpy(struct_out, str, sizeof(signed_msg));
    struct_out->msg = malloc(struct_out->size);
    memcpy(struct_out->msg, str + sizeof(signed_msg), struct_out->size);

    return MT_SUCCESS;
}

/**
 * Shortcut to sign and create a network-sendable message in less lines than
 * manually calling pack_signed_msg
 */
int create_signed_msg(byte* msg, int size, byte (*pk)[SIZE_PK], byte (*sk)[SIZE_SK], byte** str_out){
    signed_msg msg_struct;
    msg_struct.msg = msg;
    msg_struct.size = size;
    memcpy(msg_struct.pk, *pk, SIZE_PK);
    if(sig_sign(msg, size, sk, &(msg_struct.sig)) == MT_ERROR)
	return MT_ERROR;

    return pack_signed_msg(msg_struct, str_out);
}

/**
 * Converts a public key into an address for use on the ledger. The address is
 * generated by a simple hash of the public key and is 20 bytes long.
 */
int pk_to_addr(byte (*pk)[SIZE_PK], byte (*addr_out)[SIZE_ADDR]){
    byte hash[SIZE_HASH];
    paycrypt_hash(*pk, SIZE_PK, &hash);
    memcpy(*addr_out, hash, SIZE_ADDR);
    return MT_SUCCESS;
}

/**
 * Converts an address in byte-string form to a more human-readable hexadecimal
 * string. The format is in the style of Ethereum as it leads with the '0x'
 */
int addr_to_hex(byte (*addr)[SIZE_ADDR], char (*hex_out)[SIZE_ADDR * 2 + 3]){

    (*hex_out)[0] = '0';
    (*hex_out)[1] = 'x';

    for(int i = 0; i < SIZE_ADDR; i++)
	sprintf(&((*hex_out)[i*2 + 2]), "%02X", (*addr)[i]);

    (*hex_out)[SIZE_ADDR * 2 + 2] = '\0';
    return MT_SUCCESS;
}

/**
 * Compute a hash chain of the given size using the given random head. The
 * output is written to the inputted hc_out address, which is a pointer to a
 * arbitrary sized array of pointers to SIZE_HASH arrays. The ordering is such
 * that the tail of the chain is at the front of the array and the head is at
 * the rear.
 */
int hash_create_chain(int size, byte (*head)[SIZE_HASH], byte (*hc_out)[][SIZE_HASH]){
    if(size < 1)
	return MT_ERROR;

    memcpy(&((*hc_out)[size -1]), *head, SIZE_HASH);	\

    for(int i = size - 2; i >= 0; i--){
	if(paycrypt_hash((*hc_out)[i+1], SIZE_HASH, &((*hc_out)[i])) != MT_SUCCESS)
	    return MT_ERROR;
    }
    return MT_SUCCESS;
}

/**
 * Verifies the claim that a given preimage is in fact the kth element on a hash
 * chain starting at the given tail.
 */
int hash_verify_chain(byte (*tail)[SIZE_HASH], byte (*preimage)[SIZE_HASH], int k){
    byte current[SIZE_HASH];
    byte temp[SIZE_HASH];

    memcpy(current, *preimage, SIZE_HASH);
    for(int i = 0; i < k; i++){
	if(paycrypt_hash(current, SIZE_HASH, &temp) != MT_SUCCESS)
	    return MT_ERROR;
	memcpy(current, temp, SIZE_HASH);
    }

    if(memcmp(current, *tail, SIZE_HASH) != 0)
	return MT_ERROR;

    return MT_SUCCESS;
}

int commit_wallet(byte (*pp)[SIZE_PP], byte (*pk_payee)[SIZE_PK], byte *wallet, int pay_val,
		  byte (*com_out)[SIZE_COM]){
    return 0;
}

int chn_refund_verify(chn_end_close token){
    return 0;
}
