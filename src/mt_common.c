/**
 * \file payment_utils.c
 *
 * General purpose module that houses basic useful functionality for various
 * users of the moneTor payment scheme. This module will be likely updated
 * frequently as the scheme is expanded
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "mt_common.h"

static const int offset_chn_end_estab1;
    static const int offset_chn_int_estab2;
    static const int offset_chn_end_estab3;
    static const int offset_chn_int_estab4;
    static const int offset_mic_cli_pay1;
    static const int offset_mic_rel_pay2;
    static const int offset_mic_cli_pay3;
    static const int offset_mic_int_pay4;
    static const int offset_mic_cli_pay5;
    static const int offset_mic_rev_pay6;
    static const int offset_mic_int_pay7;
    static const int offset_mic_int_pay8;
    static const int offset_nan_cli_setup1;
    static const int offset_nan_int_setup2;
    static const int offset_nan_cli_setup3;
    static const int offset_nan_int_setup4;
    static const int offset_nan_cli_setup5;
    static const int offset_nan_int_setup6;
    static const int offset_nan_cli_estab1;
    static const int offset_nan_rel_estab2;
    static const int offset_nan_int_estab3;
    static const int offset_nan_rel_estab4;
    static const int offset_nan_int_estab5;
    static const int offset_nan_cli_pay1;
    static const int offset_nan_end_close1;
    static const int offset_nan_int_close2;
    static const int offset_nan_end_close3;
    static const int offset_nan_int_close4;
    static const int offset_nan_end_close5;
    static const int offset_nan_int_close6;
    static const int offset_nan_end_close7;
    static const int offset_nan_int_close8;
    static const int offset_mac_aut_mint;
    static const int offset_mac_any_trans;
    static const int offset_chn_end_escrow;
    static const int offset_chn_int_escrow;
    static const int offset_chn_int_reqclose;
    static const int offset_chn_end_close;
    static const int offset_chn_int_close;
    static const int offset_chn_end_cashout;
    static const int offset_chn_int_cashout;
    static const int offset_mac_led_data;
    static const int offset_chn_led_data;
    static const int offset_mac_led_query;
    static const int offset_chn_led_query;


uint8_t payment_command(ntype type, int number){

}

/**
 * Converts a public key into an address for use on the ledger. The address is
 * generated by a simple hash of the public key and is 20 bytes long.
 */
int pk_to_addr(byte (*pk)[SIZE_PK], byte (*addr_out)[SIZE_ADDR]){
    byte hash[SIZE_HASH];
    paycrypt_hash(*pk, SIZE_PK, &hash);
    memcpy(*addr_out, hash, SIZE_ADDR);
    return MT_SUCCESS;
}

/**
 * Converts an address in byte-string form to a more human-readable hexadecimal
 * string. The format is in the style of Ethereum as it leads with the '0x'
 */
int addr_to_hex(byte (*addr)[SIZE_ADDR], char (*hex_out)[SIZE_ADDR * 2 + 3]){

    (*hex_out)[0] = '0';
    (*hex_out)[1] = 'x';

    for(int i = 0; i < SIZE_ADDR; i++)
	sprintf(&((*hex_out)[i*2 + 2]), "%02X", (*addr)[i]);

    (*hex_out)[SIZE_ADDR * 2 + 2] = '\0';
    return MT_SUCCESS;
}

/**
 * Compute a hash chain of the given size using the given random head. The
 * output is written to the inputted hc_out address, which is a pointer to a
 * arbitrary sized array of pointers to SIZE_HASH arrays. The ordering is such
 * that the tail of the chain is at the front of the array and the head is at
 * the rear.
 */
int hash_create_chain(int size, byte (*head)[SIZE_HASH], byte (*hc_out)[][SIZE_HASH]){
    if(size < 1)
	return MT_ERROR;

    memcpy(&((*hc_out)[size -1]), *head, SIZE_HASH);	\

    for(int i = size - 2; i >= 0; i--){
	if(paycrypt_hash((*hc_out)[i+1], SIZE_HASH, &((*hc_out)[i])) != MT_SUCCESS)
	    return MT_ERROR;
    }
    return MT_SUCCESS;
}

/**
 * Verifies the claim that a given preimage is in fact the kth element on a hash
 * chain starting at the given tail.
 */
int hash_verify_chain(byte (*tail)[SIZE_HASH], byte (*preimage)[SIZE_HASH], int k){
    byte current[SIZE_HASH];
    byte temp[SIZE_HASH];

    memcpy(current, *preimage, SIZE_HASH);
    for(int i = 0; i < k; i++){
	if(paycrypt_hash(current, SIZE_HASH, &temp) != MT_SUCCESS)
	    return MT_ERROR;
	memcpy(current, temp, SIZE_HASH);
    }

    if(memcmp(current, *tail, SIZE_HASH) != 0)
	return MT_ERROR;

    return MT_SUCCESS;
}

int commit_wallet(byte (*pp)[SIZE_PP], byte (*pk_payee)[SIZE_PK], mic_end_wallet wallet, int pay_val,
		  byte (*com_out)[SIZE_COM]){
    return 0;
}

int chn_refund_verify(chn_end_close token){
    return 0;
}
