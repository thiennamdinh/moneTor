\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{varwidth}

\newcommand{\flo}[1]{ {\color{blue} [[FR: #1]]}}
\newcommand{\thi}[1]{ {\color{green} [[TD: #1]]}}

\begin{document}

\section{Overview}
Outline of where it fits into the entire incentive system
\section{Bolt Micropayments}

\section{Nanopayment Extension}

\section{Primitives}

\section{Security Model}

\subsection{Economic Security}

\subsection{Anonymity}

\section{API}

\section{Algorithms}

\begin{algorithm}
  \caption{Nanopayment Channel Setup}
  \begin{algorithmic}[1]
    \Procedure{Client}{}
      \Comment{Create new wallet commitment and nanochannel token to send to the intermediary} \\
      \State{parse $w_c$ as $(B_C, wpk_C, wsk_C, r, \sigma^w_C)$}
      \State{$(wsk'_C, wpk'_C) \gets KeyGen (pp)$}
      \State{$r' \gets Random()$}
      \State{$HC \gets Reverse(HashChain(r', n))$}

      \State{$wCom'_C \gets Commit (wpk'_C, B_C - (\delta_C * n), r')$}
      \State{$\pi_C \gets PK\{(B_C, r', \sigma^w_C)\}:$ \par}
      \State{\hskip\algorithmicindent{} $wCom'_C = Commit(wpk'_C, B_C - (\delta_C * n), r')\ \wedge$}
      \State{\hskip\algorithmicindent{} $Verify(pk_I, (wpk_C, B_C), \sigma^w_C) = 1\ \wedge$}
      \State{\hskip\algorithmicindent{} $0 \leq (B_C - \delta_C) \leq val_{\max}$}

      \State{$nT \gets (wpk'_C, \delta_C, n, HC[0])$}
      \State{$Intermediary.Send(wpk_C, wCom'_C, \pi_C, nT)$}
    \EndProcedure{} \\

    \Procedure{Intermediary}{}
      \Comment{Verify client info and notify the client} \\
      \State{$(wpk_C, wCom'_C, \pi_C, nT) \gets Client.Receive()$}
      \If{$wpk_C \in S_I \vee \neg Verify(\pi_C) \vee \delta_C \ne network\_price$}
        \State{$Abort()$}
      \EndIf{}

      \State{$S_I \gets S_I \cup (wpk_C : \bot)$}
      \State{$nS_I \gets nS_I \cup (nT : \bot)$}
      \State{$Client.Send(verified)$}
    \EndProcedure{} \\

    \Procedure{Client}{}
      \Comment{Obtain a refund token that is encumbered with the nanochannel hash chain} \\
      \State{$verified \gets Intermediary.Receive()$}
      \State{$rt^{w'}_C \gets Intermediary.Blindsig(refund || HC[0] || wpk'_C || B - (\delta_C * n))$}
      \If{$\neg Verify(pk_I, rt^{w'}_C, refund || HC[0] || wpk'_C || B - (\delta_C * n))$}
        \State{$Ledger.Post(rt_{w'})$}
        \State{$Abort()$}
      \EndIf{}
      \State{$nS_C \gets (0)$} \Comment{client state: simply the number of payments made}
      \State{$ncsk_C \gets (wpk_C, wsk'_C, HC)$}
      \State{$\sigma^{rev(w)}_C \gets Sign(wsk_C, revoke||wpk_C)$}
      \State{$Intermediary.Send(\sigma^{recv(w)}$)}
    \EndProcedure{} \\

    \Procedure{Intermediary}{}
      \Comment{Obtain a revocation of the client's old wallet and activate the nanopayment channel} \\
      \State{$\sigma^{recv(w)} \gets Client.Receive()$}
      \If{$if(\neg Verify(wpk, revoke||wpk_C, \sigma^{recv(w)}) = 1)$}
        \State{$Abort()$}
      \EndIf{}
      \State{$S_I[wpk_C] \gets \sigma^{recv(w)})$}
      \State{$nS_I[nT] \gets ready)$}
      \State{$Client.Send(established)$}
    \EndProcedure{}

  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Nanopayment Channel Establish}
  \begin{algorithmic}[1]

    \Procedure{Client}{}
      \Comment{Send nanopayment token to the relay} \\
      \State{$Relay.Send(nT)$}
    \EndProcedure{} \\

    \Procedure{Relay}{}
      \Comment{Create a commitment to new wallet and send to the intermediary along with the nanopayment channel token}
      \State{$(nT) \gets Client.Receive()$}
      \State{parse $w_R$ as $(B_R, wpk_R, wsk_R, r, \sigma^w_R)$}
      \State{$(wsk'_R, wpk'_R) \gets KeyGen (pp)$}
      \State{$r' \gets Random()$}
      \State{$HC \gets Reverse(HashChain(r', n))$}

      \State{$wCom'_R \gets Commit (wpk'_R, B_R - (\delta_R * n), r')$}
      \State{$\pi_R \gets PK\{(B_R, r', \sigma^w_R)\}:$ \par}
      \State{\hskip\algorithmicindent{} $wCom'_R = Commit(wpk'_R, B_R - (\delta_R * n), r')\ \wedge$}
      \State{\hskip\algorithmicindent{} $Verify(pk_I, (wpk_R, B_R), \sigma^w_R) = 1\ \wedge$}
      \State{\hskip\algorithmicindent{} $0 \leq (B_R - \delta_R) \leq val_{\max}$}
      \State{$Intermediary.Send(wpk_R, wCom'_R, \pi_R, nT, \delta_R)$}
    \EndProcedure{} \\

    \Procedure{Intermediary}{}
      \Comment{Verify the new wallet and, if the nanopayment channel token is valid, mark the token as established so that it can't be used for another channel. Send a refund token to the relay} \\
      \State{$(wpk_R, wCom'_R, \pi_R, nT, \delta_R) \gets Relay.Receive()$}

      \If{$wpk_R \in S_I \vee \neg Verify(\pi_R) \vee \delta_c - \delta_R \ne tax\_rate$}
        \State{$Abort()$}
      \EndIf{}

      \If{$nS_I[nT] \ne ready$}
        \State{$Relay.Send(\bot)$}
        \State{$Abort()$}
      \EndIf{}

      \State{$nS_I[nT] \gets established$}
      \State{$rt^{w'}_R \gets Sign(refund || hc_0 || wpk'_R, B - (\delta*n))$}
      \State{$Relay.Send(rt^{w'}_R)$}
    \EndProcedure{} \\

    \Procedure{Relay}{}
      \Comment{Verify and create a nanopayment state for the relay (number of payments and latest preimage)} \\
      \State{$rt^{w'}_R \gets Intermediary.Receive()$}
      \If{$rt^{w'}_R = \bot$}
        \State{$Abort()$}
      \EndIf{}
      \State{$nS_R \gets (0, hc_0)$}
    \EndProcedure{}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Nanopayment Channel Pay}
  \begin{algorithmic}[1]

    \Procedure{Client}{}
      \Comment{Make sure that we still have payments left to send and forward the next preimage} \\
      \State{parse $nS_C$ as $(k)$}
      \State{parse $nT$ as $(wpk'_C, \delta, n, HC[0])$}
      \State{parse $ncsk_C$ as $(wpk_C, wsk'_C, HC)$}

      \If{$k >= n$}
        \State{Abort, and setup/establish a new micropayment channel}
      \EndIf{}

      \State{$nS_C \gets k+1$}
      \State{$Relay.Send(HC[k+1])$}
    \EndProcedure{} \\

    \Procedure{Relay}{}
      \Comment{Verify the preimage and update the state} \\
      \State{$hc_{k+1} \gets Client.Receive()$}
      \State{parse $nS_R$ as $(hs_k, k)$}
      \If{$k >= n \vee Hash(hc_{k+1}) \ne hc_k$}
        \State{$Abort()$}
      \EndIf{}
      \State{$nS_R \gets (hs_{k+1}, k+1)$}
    \EndProcedure{}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Nanopayment Channel Relay Close}
  \begin{algorithmic}[1]
    \State
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Nanopayment Channel Client Close}
  \begin{algorithmic}[1]
    \State
  \end{algorithmic}
\end{algorithm}


\end{document}