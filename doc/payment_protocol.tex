\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{parskip}
\usepackage{varwidth}
\usepackage{placeins}
\usepackage{xcolor}
\newcommand{\flo}[1]{ {\color{blue} [[FR: #1]]}}
\newcommand{\thi}[1]{ {\color{red} [[TD: #1]]}}

\begin{document}

\section{Overview}
Outline of where it fits into the entire incentive system
\section{Bolt Micropayments}

\section{Nanopayment Extension}

\section{Primitives}

\section{Security Model}

\subsection{Economic Security}

\subsection{Anonymity}

\section{API}

\section{Variable Index} \label{variable index}

In following with the Bolt style, variables in the section
\ref{algorithms} are separated into two levels. The first level of
variables are used for actual cryptographic and accounting
operations. These are bundled into groups of higher level variable
names meant to represent abstraction concepts such as payment channels
and party states. Only these high level variables are saved outside
the context of the algorithms.

\textbf{Shared}

$nT = (\delta_C, \delta_R, n, hc^0)$ - ``Nanopayment Channel Token'' -
This token stores the static, public information that defines a
nanopayment channel including the payment values on both legs, the max
number of payments, and the hashchain head. This can be passed around
freely by all parties.

\textbf{Client}

$ncsk_C = (nwpk_C, nwsk_C, HC)$ - ``Client Nanopayment Secrets'' - The
public/private key pair allows the client to setup and close a
nanopayment channel while the precomputed hash chain stores the
ability to make incremental nanopayments

$nS_C = (k, hc^k)$ - ``Client Nanopayment State'' - The mutable state
of the nanopayment is simply the count of payments made so far and the
latest sent hash pre-image

$nrt_C$ - ``Client Nanopayment Refund'' - The refund token allows the
client to make a claim to the ledger on escrowed money. This refund is
signed by the intermediary and conditioned on revealing the latest
hash pre-image that the client claims to have sent.

\textbf{Intermediary}

$nS_I = \{nT: channel\_state\}$ - ``Intermediary Nanopayment State''
The intermediary's nanopayment state is a map of all past and present
nanopayment channels and the corresponding channel state. Possible
states are:
\begin{itemize}
\item $\bot$ - failed attempt at setting up a nanopayment channel
\item $ready$ - channel has been set up by the sender (client)
\item $established$ - channel has been established with a recipient
  (relay)
\item $closed||hc^k$ - channel has been closed and no further payments
  are allowed
\end{itemize}

\textbf{Relay}

$ncsk_R (nwpk_C, nwsk_C, \bot)$ - ``Relay Nanopayment Secrets'' - The
public/private key pair allows the relay to setup and close a
nanopayment channel. Since relays cannot make payments in this setup,
the last field is left blank.

$nS_R = (k, hc^k)$ - ``Relay Nanopayment State'' - The mutable state
of the nanopayment is simply the count of payments made so far and the
latest received hash pre-image

$nrt_R$ - ``Relay Nanopayment Refund'' - The refund token allows the
relay to make a claim to the ledger on escrowed money. This refund is
signed by the intermediary and conditioned on revealing the latest
hash pre-image that the relay has received.

\flo{How does the transaction happens on the ledger?}
\thi{Basically, the client/relay would send the refund token to the ledger and that transaction would be posted. There would be some delay period in which the intermediary might want to refute the claim by posting a revocation token and it should be obvious to the ledger/network that one of them is right. These steps should probably be formalized in nRefund, nRefute, and nResolve algorithms}
\section{Algorithms} \label{algorithms}

Conventions:
\begin{itemize}
\item All variable names in this section are globally unique.
\item Variable subscripts denote a party or role ((I)ntermediary,
  (C)lient, (R)elay, (E)nd user).
\item New nanopayment variables are prefixed with the character
  (n). All other variables reference a value from the original Bolt
  scheme, although the name might be altered somewhat.
\item Payment values ($\epsilon, \delta$) are signed integers with
  respect to the end user. For example, $\delta_C$ is negative and
  $\delta_R$ is positive in the typical case where a client is paying
  a relay.
\end{itemize}

\begin{algorithm}
  \begin{algorithmic}[1]
    \caption{Helper Functions}
    \Function{CommitWallet}{$pp, pk_{payee}, w, \epsilon$}
    \State{parse $w$ as $(B, wpk, wsk, r, \sigma^w)$}
    \State{$(wsk', wpk') \gets $KeyGen$(pp)$}
    \State{$r' \gets $Random$()$}
    \State{$wCom' \gets $Commit$(wpk', B + \epsilon, r')$}
    \State{$\pi \gets PK\{(wpk', B, r', \sigma^{w_{old}})\}$: \par}
    \State{\hskip\algorithmicindent{} $wCom' = $Commit$(wpk', B + \epsilon, r')\ \wedge$}
    \State{\hskip\algorithmicindent{} Verify$(pk_{payee}, (wpk, B), \sigma^w) = 1\ \wedge$}
    \State{\hskip\algorithmicindent{} $0 \leq (B + \epsilon)$ \par}
    \Return{$(wsk', wpk', wCom', \pi)$}
    \EndFunction{}
  \end{algorithmic}
  \flo{(7) is redundant with (5)?}
  \thi{Not quite; line (5) is where the commitment is actually created. Line (7) is part of a zero-knowledge proof $(\pi)$ that shows that the commitment was properly constructed since the other party ($I$ in this case) doesn't know wpk', B, or r'}
\end{algorithm}

\begin{algorithm}
  \caption{Nanopayment Channel Setup}
  \begin{algorithmic}[1]
    \Procedure{Client}{$pp, pk_I, w_C, \delta_C, n$}
      \State{parse $w_C$ as $(B_C, wpk_C, wsk_C, r_C, \sigma^w_C)$}
      \If{$B_{C} + (\delta_C * n) < 0$}
        \flo{is $\delta_C$ supposed to be negative as you said above?}
        \thi{Yep, just fixed it. Thanks!}
        \State{Abort(Consider opening a new micropayment channel)}
      \EndIf{}
      \State{$(nwpk_C, nwsk_C, nwCom_C, n\pi_C) \gets $CommitWallet$(pp, pk_I, w_C, \delta_C * n)$}
      \State{$\delta_R \gets -(tax - \delta_C)$}
      \State{$HC \gets \{\}$}
      \State{$HC[n-1] \gets $Random$()$}
      \For{$i = \{n-2, \ldots, 0\}$}
        \State{$HC[i] = $Hash$(HC[i+1])$}
      \EndFor{}
      \State{$nT \gets (\delta_C, \delta_R, n, HC[0])$}
      \State{Intermediary.Send$(wpk_C, nwCom_C, n\pi_C, nT)$}
    \EndProcedure{}

    \Procedure{Intermediary}{$pp, S_I, nS_I$}
      \State{$(wpk_C, nwpk_C, nwCom_C, n\pi_C, nT) \gets $Client.Receive()}
      \State{parse $nT$ as $(\delta_C, \delta_R, n, hc^0)$}
      \If{$wpk_C \in S_I \vee \neg $Verify$(n\pi_C)$}
        \State{Abort(Invalid wallet)}
      \EndIf{}
      \If{$-\delta_C = price \vee \delta_R + \delta_C + tax = 0$}
        \State{Abort(Incorrect payment prices)}
      \EndIf{}
      \State{$S_I \gets S_I \cup (wpk_C : \bot)$}
      \State{$S_I \gets S_I \cup (nwpk_C : \bot)$}
      \State{$nS_I \gets nS_I \cup (nT : \bot)$}
      \State{Client.Send$(verified)$}
    \EndProcedure{}

    \Procedure{Client}{}
      \State{$ver \gets $Intermediary.Receive()}
      \State{$nrt_C \gets $Intermediary.Blindsig$(v, refund || HC[0] || nwpk_C || B + (\delta_C * n))$}
      \State{$nS_C \gets (0, HC[0])$}
      \State{$ncsk_C \gets (nwpk_C, nwsk_C, HC)$}
      \State{$\sigma^{rev(w)}_C \gets $Sign$(wsk_C, revoke||wpk_C)$}
      \State{Intermediary.Send$(\sigma^{recv(w)}$)}
    \EndProcedure{}

    \Procedure{Intermediary}{}
      \State{$\sigma^{recv(w)} \gets $Client.Receive()}
      \If{$if(\neg $Verify$(wpk, revoke||wpk_C, \sigma^{recv(w)}) = 1)$}
        \State{Abort(Invalid revocation token)}
      \EndIf{}
      \State{$S_I[wpk_C] \gets \sigma^{recv(w)}$}
      \State{$nS_I[nT] \gets ready$}
      \State{Client.Send$(established)$}
    \EndProcedure{}

  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Nanopayment Channel Establish}
  \begin{algorithmic}[1]

    \Procedure{Client}{$nT$}
      \State{Relay.Send$(nT)$}
    \EndProcedure{}

    \Procedure{Relay}{$pp, pk_I, w_R$}
      \State{$(nT) \gets $Client.Receive()}
      \State{parse $w_R$ as $(B_R, wpk_R, wsk_R, r_R, \sigma^w_R)$}
      \State{parse $nT$ as $(\delta_C, \delta_R, n, hc^0)$}
      \If{$B_{I:B} - (\delta_B * n) < 0$}
        \State{Abort(Consider opening a new micropayment channel)}
      \EndIf{}
      \State{$(nwpk_R, nwsk_R, nwCom_R, n\pi_R) \gets $CommitWallet$(pp, pk_I, w_R, \delta_R * n)$}
      \State{Intermediary.Send$(nwpk_R, nwCom_R, n\pi_R, nT)$}
    \EndProcedure{}

    \Procedure{Intermediary}{$pp, S_I, nS_I$}
      \State{$(nwpk_R, nwCom_R, \pi_R, nT) \gets $Relay.Receive()}
      \State{parse $nT$ as $(\delta_C, \delta_R, n, hc^0)$}
      \If{$nS_I[nT] \ne ready$}
        \State{Abort(Unregistered nanopayment channel)}
      \EndIf{}

      \State{$S_I \gets S_I \cup (nwpk_R, \bot)$}
      \State{$nS_I[nT] \gets established$}
      \State{Relay.Send$(verified)$}
    \EndProcedure{}

    \Procedure{Relay}{}
      \State{$ver \gets $Intermediary.Receive()}
      \State{$nrt_R \gets $Intermediary.Blindsig$(ver, refund || hc^0 || nwpk_R || B_R + (\delta_R * n))$}
      \State{$ncsk_R \gets (nwpk_R, nwsk_R, \bot)$}
      \State{$nS_R \gets (0, hc^0)$}
    \EndProcedure{}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Nanopayment Channel Pay}
  \begin{algorithmic}[1]

    \Procedure{Client}{$nT, ncsk_C, nS_C$}
      \State{parse $nT$ as $(\delta_C, \delta_R, n, hc^0)$}
      \State{parse $ncsk_C$ as $(nwpk_C, nwsk_C, HC)$}
      \State{parse $nS_C$ as $(k, HC[k])$}

      \If{$k >= n$}
        \State{Abort(Out of nanopayments to send, setup a new channel)}
        \flo{nClose here?}
        \thi{Maybe... I'm not sure whether it makes more sense to specify it locally here or push it off to the ``higher level'' control loop of whoever is calling this algorithm. We'd also have to send a signal to the relay to close his channel first and then go through setup/establish steps again. Also, to save cpu cycles, this would be where we look ``rolling into the next nanopayment channel'' efficiency shortcuts that Dan was talking about}
      \EndIf{}

      \State{$nS_C \gets (k+1, HC[k])$}
      \State{Relay.Send$(HC[k+1])$}
    \EndProcedure{}

    \Procedure{Relay}{$nT, nS_R$}
      \State{$hc^{k+1} \gets $Client.Receive()}
      \State{parse $nS_R$ as $(hs^k, k)$}
      \If{$k >= n \vee Hash(hc^{k+1}) \ne hc^k$}
        \State{Abort(Invalid nanopayment)}
      \EndIf{}
      \State{$nS_R \gets (hs^{k+1}, k+1)$}
    \EndProcedure{}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Nanopayment Channel Close}
  \begin{algorithmic}[1]
    \State{$\forall E \in \{Client, Relay\}$}
    \Procedure{Relay}{$pp, pk_I, w_E, nT, ncsk_E, nS_E$}
      \State{parse $w_E$ as $(B_E, wpk_E, wsk_E, r, \sigma^w_E)$}
      \State{parse $nT$ as $(\delta_C, \delta_R, n, hc^0)$}
      \State{parse $ncsk_E$ as $(nwpk_E, nwsk_E, \_)$}
      \State{parse $nS_E$ as $(k, hc^k)$}
      \State{$\epsilon_E \gets \delta_C * k$ if (End User = Client) else $ \delta_R * k$}
      \State{$(wCom'_E, \pi'_E) \gets $CommitWallet$(pp, pk_I, wpk_B, \sigma^w_E, B_E, \epsilon_E$)}
      \State{Intermediary.Send$(wpk_E, wCom'_E, \pi_E, nT, \epsilon_E, hc^k)$}
    \EndProcedure{}

    \Procedure{Intermediary}{$pp, S_I, nS_I$}
      \State{$(wpk_E, wCom'_E, \pi_E, nT, \epsilon_E, hc^k) \gets $Relay.Receive()}
      \If{$\epsilon_E < 0 \wedge closed \not\in nS_I[nT]$}
        \State{Abort(Client attempting to close before relay)}
      \EndIf{}
      \State{parse $nT$ as $(\delta_C, \delta_E, n, hc^0)$}
      \State{$hc^i \gets hc^k$}
      \For{$i \gets \{k-1, \ldots , 0\}$}
        \State{$hc^i \gets Hash(hc^i)$}
      \EndFor{}
      \If{Verify$(\pi_E) \vee nS_I[nT] \ne established \vee hc^i \ne hc^0$}
        \State{Abort(Invalid wallet, channel, or hash chain)}
      \EndIf{}
      \State{$nS_I[nT] \gets (nT, closed||hc^k)$}
      \State{Relay.Send$(verified)$}
    \EndProcedure{}

    \Procedure{Relay}{}
      \State{$ver \gets $Intermediary.Receive()}
      \State{parse $ncsk_E$ as $(nwpk_E, nwsk_E)$}
      \State{$nrt_E \gets $Intermediary.Blindsig$(ver, refund || hc^0 || nwpk_E || B_E + (\delta_E * n))$}
      \State{$\sigma^{rev(nrt)}_E \gets $Sign$(nwsk_E, revoke||nwpk_E)$}
      \State{Intermediary.Send$(nwpk_E, \sigma^{rev(nrt)})$}
    \EndProcedure{}

    \Procedure{Intermediary}{}
      \State{$\sigma^{rev(nrt)}_E \gets $Relay.Receive()}
      \If{$nwpk_E n\in S_I \vee \neg $Verify$(nwpk_E, \sigma^{rev(nrt)})$}
        \State{Abort(Unregistered nanopayment channel or revocation token)}
      \EndIf{}
      \State{$S_I[nwpk_E] \gets \sigma^{rev(nrt)}$}
      \State{Relay.Send$(verified)$}
    \EndProcedure{}

    \Procedure{Relay}{}
      \State{$ver \gets $Intermediary.Receive()}
      \State{$w'_E \gets $Intermediary.Blindsig$(ver, wpk_E'||B_E + \epsilon_E)$}
    \EndProcedure{}

  \end{algorithmic}
\end{algorithm}


\end{document}
